# `tahini` Macro System

`tahini` features a powerful macro system for metaprogramming. Macros allow for code generation and transformation at
compile time. This document describes how to define and use macros in `tahini`.

## Macro Definition

Macros are defined using the `macro` keyword:

```lisp
(def macro-name (macro [param1 param2 ...] 
  body
))
```

### Simple Macro Example

```lisp
;; Define a simple unless macro
(def unless (macro [condition then-expr else-expr]
  `(if (not ,condition)
      ,then-expr
      ,else-expr)
))

;; Using the macro
(unless (= x 0)
  (/ 10 x)
  0)

;; Expands to:
;; (if (not (= x 0))
;;   (/ 10 x)
;;   0)
```

## Quoting and Unquoting

`tahini` uses several quoting mechanisms for macro manipulation:

- Quote (`'`): Prevents evaluation, creating literal expressions
- Quasi-quote (`` ` ``): Like quote, but allows unquoting within
- Unquote (`,`): Inside a quasi-quote, evaluates the expression
- Unquote-splicing (`,@`): Inside a quasi-quote, evaluates to a list and splices it in

### Quoting Examples

```lisp
;; Quote
(def expr '(+ 1 2))  ; expr is the list (+ 1 2), not the value 3

;; Quasi-quote with unquote
(def x 10)
(def y 20)
(def expr `(+ ,x ,y))  ; expr is (+ 10 20)

;; Unquote-splicing
(def numbers '(1 2 3))
(def expr `(+ ,@numbers))  ; expr is (+ 1 2 3)
```

## Macro Expansion

Macros are expanded at compile time, replacing macro calls with the generated code:

```lisp
;; Define a swap macro
(def swap (macro [a b]
  `(do
     (def temp ,a)
     (def ,a ,b)
     (def ,b temp)
   )
))

;; Using the swap macro
(swap x y)

;; Expands to:
;; (do
;;   (def temp x)
;;   (def x y)
;;   (def y temp)
;; )
```

## Hygiene

`tahini` macros are not automatically hygienic - they can introduce variable names that might conflict with existing
variables. To avoid conflicts, use unique names for temporary variables:

```lisp
;; Non-hygienic swap (potential name collision with "temp")
(def swap-bad (macro [a b]
  `(do
     (def temp ,a)
     (def ,a ,b)
     (def ,b temp)
   )
))

;; More hygienic swap with less common temporary variable name
(def swap-better (macro [a b]
  `(do
     (def __swap_temp__ ,a)
     (def ,a ,b)
     (def ,b __swap_temp__)
   )
))
```

## Complex Macro Examples

### Control Flow Macros

```lisp
;; when macro (if without else)
(def when (macro [condition & body]
  `(if ,condition
     (do ,@body)
     ()  ; Empty expression for else branch
   )
))

;; for-each macro
(def for-each (macro [var items & body]
  `(do
     (def __items ,items)
     (def __len (array-length __items))
     (for (range __i __len)
       (do
         (def ,var ($ [__i] __items))
         ,@body
       )
     )
   )
))

;; Using the macros
(when (> x 0)
  (stdio/printf "x is positive: %d\n" x)
  (def positive true)
)

(for-each item items
  (stdio/printf "Item: %d\n" item)
  (process item)
)
```

### Binding Macros

```lisp
;; let macro for local bindings
(def let (macro [bindings & body]
  (do
    (def pairs (partition bindings 2))
    (def names (map first pairs))
    (def values (map second pairs))
    
    `(do
       ,@(map (fn [name value] `(def ,name ,value)) names values)
       ,@body
     )
  )
))

;; Using the let macro
(let [x 10
      y 20
      z (+ x y)]
  (stdio/printf "x = %d, y = %d, z = %d\n" x y z)
)

;; Expands to:
;; (do
;;   (def x 10)
;;   (def y 20)
;;   (def z (+ x y))
;;   (stdio/printf "x = %d, y = %d, z = %d\n" x y z)
;; )
```

### Domain-Specific Language (DSL) Macros

```lisp
;; HTML generation DSL
(def html-element (macro [tag attrs & children]
  `(str-concat
     ,(str-concat "<" tag)
     ,(if attrs
         `(str-concat " " (attrs-to-string ,attrs))
         "")
     ">"
     ,@(map (fn [child] `(to-string ,child)) children)
     ,(str-concat "</" tag ">")
   )
))

;; Define common HTML elements
(def html (macro [& children]
  `(html-element "html" () ,@children)
))

(def body (macro [& children]
  `(html-element "body" () ,@children)
))

(def div (macro [attrs & children]
  `(html-element "div" ,attrs ,@children)
))

;; Using the HTML DSL
(html
  (body
    (div {:class "container"}
      (div {:class "header"} "Hello, World!")
      (div {:class "content"} "This is content generated by `tahini` macros.")
    )
  )
)
```

## Recursive Macros

Macros can be recursive, allowing for complex code generation:

```lisp
;; Recursive macro to generate nested if-else chains
(def cond (macro [& clauses]
  (if (= (length clauses) 0)
    '()  ; Empty cond returns empty expression
    (if (= (length clauses) 1)
      (first clauses)  ; Only one clause (the else clause)
      `(if ,(first clauses)
         ,(second clauses)
         (cond ,@(rest (rest clauses)))
       )
    )
  )
))

;; Using the cond macro
(cond
  (< x 0) "negative"
  (> x 0) "positive"
  "zero"
)

;; Expands to:
;; (if (< x 0)
;;   "negative"
;;   (if (> x 0)
;;     "positive"
;;     "zero"
;;   )
;; )
```

## Macro Utilities

### Generating Unique Symbols

For more complex macros, you might want to generate unique symbols to ensure hygiene:

```lisp
;; Generate a unique symbol based on a prefix
(def gensym (fn [prefix] 
  (str-concat prefix "_" (int-to-str (get-unique-id)))
))

;; Using gensym in macros
(def with-lock (macro [lock & body]
  (do
    (def lock-var (gensym "lock"))
    `(do
       (def ,lock-var ,lock)
       (lock/acquire ,lock-var)
       (do ,@body)
       (lock/release ,lock-var)
     )
  )
))
```

### Macro Debugging

To debug macros, you can use the `macroexpand` function to see the expanded code without executing it:

```lisp
;; See the expansion of a macro
(macroexpand '(unless (= x 0) (/ 10 x) 0))
;; -> (if (not (= x 0)) (/ 10 x) 0)

;; See the expansion of nested macros
(macroexpand-all '(when (> x 0) (for-each item items (process item))))
```

## Best Practices

1. **Avoid variable capture**: Use unique names for temporary variables or use `gensym`.
2. **Keep macros simple**: Complex macros are hard to debug and understand.
3. **Document expansion**: Document how your macros expand to help users understand them.
4. **Use functions when possible**: Only use macros when you need to control evaluation or generate code.
5. **Test expansions**: Verify that your macros expand to the expected code. 